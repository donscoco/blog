<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux网络管理]]></title>
    <url>%2F2018%2F11%2F24%2FLinux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[linux网络配置linux配置IP地址ifconfig命令临时配置IP地址ifconfig:查看与配置网络状态命令；相当于windows中的 ipconfigifconfig eth0 192.168.0.200 netmask 255.255.255.0–临时设置eth0网卡的ip地址和子网掩码 12345678910111213141516[root@VM_0_8_centos ~]# ifconfigeth0 Link encap:Ethernet HWaddr 52:54:00:94:51:EE inet addr:172.16.0.8 Bcast:172.16.15.255 Mask:255.255.240.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:4720653 errors:0 dropped:0 overruns:0 frame:0 TX packets:4873615 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3306184967 (3.0 GiB) TX bytes:3313174495 (3.0 GiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:413 errors:0 dropped:0 overruns:0 frame:0 TX packets:413 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:22923 (22.3 KiB) TX bytes:22923 (22.3 KiB) 这里显示的两块eth0和lo是linux中的两块网卡lo是每个服务器都有的，没有实际使用，只用来表示，当前协议是正常的Link encap:Ethernet当前网络类型是以太网HWaddr 52:54:00:94:51:EE网卡物理地址MACinet addr:172.16.0.8 Bcast:172.16.15.255 Mask:255.255.240.0 当前ip地址，广播地址，子网掩码UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 当前网卡参数RX packets:4720653 errors:0 dropped:0 overruns:0 frame:0 当前接收到的数据包TX packets:4873615 errors:0 dropped:0 overruns:0 carrier:0当前发送的数据包RX bytes:3306184967 (3.0 GiB) TX bytes:3313174495 (3.0 GiB)接收数据包总大小和发送数据包的总大小 setup工具永久配置IP地址setup是红帽专有的图形化工具，不用setup也可以使用修改linux网络配置文件service network restart使修改生效 网络配置文件网卡信息文件/etc/sysconfig/network-scripts/ifcfg-eth0内容如下 1234567891011[root@VM_0_8_centos ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0# Created by cloud-init on instance boot automatically, do not edit.#BOOTPROTO=dhcpDEVICE=eth0HWADDR=52:54:00:94:51:eeNM_CONTROLLED=noONBOOT=yesTYPE=EthernetUSERCTL=noPERSISTENT_DHCLIENT=yes 对于网卡信息的配置通常包括：配置IP地址、子网掩码和网关。网卡信息保存在网卡配置文件中。网卡配置文件位于/etc/sysconfig/network-scripts目录下。一块网卡对应一个网卡配置文件，配置文件命名规则：ifcfg-网卡类型以及网卡的序列号由于以太网卡类型是eth，网卡的序列号从0开始，所以第一块网卡的配置文件名称为ifcfg-eth0，第二块网卡为ifcfg-eth1，以此类推。网卡配置文件中常用配置文件名的还以如下：|参数项|作用描述||–|–||DEVICE=eth0|定义该网卡的识别名称||BOOTPROTO=dhcp|是否自动获取IP（none，static，dhcp）static/none：代表固定的IP地址；bootp/dhcp：通过BOOTP或DHCP协议取得IP地址||HWADDR=52:54:00:94:51:ee|该网卡的MAC地址||HWADDR=52:54:00:94:51:ee|该网卡的MAC地址||ONBOOT=yes|启动network服务时，是否启用该网卡。当RedHat系统启动network服务时，network服务一次读取保存于/etc/sysconfig/network-scripts/目录下所有网卡的配置文件。如果网卡配置文件的ONBOOT设置为yes，则network服务就会调用ifup命令启动该网卡；如果网卡的配置文件的ONBOOT参数为no，network会跳过启动这个网卡的工作。||TYPE=Ethernet|网卡的类型，以太网||USERCTL=no|是否允许普通用户启动或者停止该网卡，一般设置no只能root操作||IPV6INIT=no|是否在该网卡上启动IPV6的功能||PEERDNS=yes|是否允许网卡在启动时向DHCP服务器查询DNS信息，并自动覆盖/etc/resolv.conf配置文件||IPADDR=192.168.1.55|静态方式指定网卡的IP地址，置项用于指定该网卡的静态IP地址，此时BOOTPROTO必须为static或者none||NETMASK=255.255.255.0|定义该网卡的子网掩码||GATEWAY=192.168.1.1|设置网络的默认网关||DNS1=192.168.128.5|指定主要的DNS服务器地址||DNS2=192.168.128.6|指定备用的DNS服务器地址||UUID=|唯一识别码||MTU=1500|设置网卡的MAC帧最大传输单位大小| BOOTPROTO=dhcp 如果局域网内没有DHCP服务器，则无法使用 更多参考：https://www.cnblogs.com/wolfkingzzy/archive/2012/04/07/Linux%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.htmlhttps://www.imooc.com/video/5223 主机名文件/etc/sysconfig/network 12345[root@VM_0_8_centos ~]# cat /etc/sysconfig/network# Created by cloud-init on instance boot automatically, do not edit.#NETWORKING=yesHOSTNAME=VM_0_8_centos NETWORKING必须为yes，为no，网络无法工作HOSTNAME为主机名，在windows中相同局域网下不能有同样的主机名，而linux中无所谓； DNS配置文件/etc/resolv.conf nameserver 名称服务器，如果有多个，可以空格接上其他的 linux网络命令网络环境查看命令ifconfig关闭和启动网卡 ifdown 网卡设备名（eth0，ol等） –禁用该网卡设备 ifup 网卡设备名 –启用该网卡设备 查询网络状态netstatnetstat [option]-t 列出TCP协议端口-u 列出UDP协议端口-n 不使用域名与服务器名，而使用ip地址和端口号-l 仅列出在监听状态的网络服务-a 列出所有网络连接-rn 相当于 route -n netstat -tuln看到在监听对应的端口号知道了对应服务开启了 netstat -an![img]可以看到自己写的一些程序 想查看ESTABLISHED连接数netstat -an |grep ESTABLISHED | wc -l这里wc -l 看行数 各项解释1、0.0.0.0代表本机上可用的任意地址。 比如0.0.0.0:135 表示本机上所有地址的135端口，这样多ip计算机就不用重复显示了。2、TCP 0.0.0.0:80表示在所有的可用接口上监听TCP80端口3、0.0.0.0为默认路由，即要到达不再路由表里面的网段的包都走0.0.0.0这条规则然后127.0.0.1就是表示本机ip地址的意思了。[::]:21表示ipv6的21号端口的意思。还有UDP的外部链接怎么都是:呢？：是网址的通配符，就是192.168.15.12，这个类型的整体描述。 各状态意义表| statu | description || :—: | :—: || LISTEN | (Listening for a connection.)侦听TCP端口的连接请求|| SYN-SENT | (Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)发送连接请求后等待匹配的连接请求|| SYN-RECEIVED | (Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)收到和发送一个连接请求后等待对方对连接请求的确认|| ESTABLISHED | (Connection established.)代表一个打开的连接|| FIN-WAIT-1 | (Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认|| FIN-WAIT-2 | (Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求|| CLOSE-WAIT | (Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求|| CLOSING | (Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认|| LAST-ACK |(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认|| TIME-WAIT |(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认|| CLOSED |(Connection is closed.)没有任何连接状态| routeroute [option]-n 查看路由列表 nslookupnslookup 主机名或者ip进行域名或者ip地址解析 12345678910111213[root@VM_0_8_centos ~]# nslookup dosncoco.github.ioServer: 183.60.83.19Address: 183.60.83.19#53Non-authoritative answer:Name: dosncoco.github.ioAddress: 185.199.109.153Name: dosncoco.github.ioAddress: 185.199.108.153Name: dosncoco.github.ioAddress: 185.199.110.153Name: dosncoco.github.ioAddress: 185.199.111.153 ServerDNS服务器地址 网络测试命令pingping [option] ip或域名-c ping次数探测指定ip或者域名的网络状况 telnettelnet [域名或ip] [端口]远程管理与端口探测命令不加密，相对于的加密：ssh traceroutetraceroute [option] 域名或ip-n 使用ip，不使用域名，速度更快可以追踪路由经过哪里，一般用来路由故障定位（不通） wgetwget url下载命令 tcpdumptcpdump -i eth0 -nnX port 21-i 指定网卡接口-nn 将数据包中的域名与服务转为IP和端口-X 以十六进制和ASCII码显示数据包内容port 指定监听端口 更多：https://www.imooc.com/video/5454 远程登录SSH 协议原理对称加密算法采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密 非对称加密算法又名公开密钥加密算法，需要两个密钥，公开密钥和私有密钥 安全外壳协议sshssh是由非对称加密演变而来的ssh username@ip_addrexit退出scp [-r] 用户名@ip:文件路径 本地路径 下载文件 如果是目录要加-rscp [-r] 本地文件 用户名@ip:上传路径 上传文件 如果是目录要加-r 1234[root@VM_0_8_centos ~]# ssh donscoco@47.93.233.184The authenticity of host '47.93.233.184 (47.93.233.184)' can't be established.RSA key fingerprint is 2b:97:15:e1:fa:3c:14:fa:9b:48:48:62:0e:32:d7:6d.Are you sure you want to continue connecting (yes/no)? 会询问是否下载对方的公钥下载的公钥会放在家目录下的 .ssh 中的 known_hosts这里如果对方重新生成公钥或者计算机重装系统之类的。原来的下载在我们这边的公钥会无法使用，只需要删除即可，下次连接的时候又会询问我们是否下载公钥]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux权限管理]]></title>
    <url>%2F2018%2F11%2F24%2Flinux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言这里只是在学习linux相关知识过程中，对常用命令做的一个总结笔记更多linux相关知识可访问 http://linux.vbird.org/ 学习 文件基本权限 常见文件类型有7种，除了上面3种，还有套接字文件，管道符文件系统文件等 基本权限的作用读r 写w 执行x 关于目录和文件的权限之间的关系，联系文件在硬件中的分区，区块来思考；例如，我对一个文件没有任何权限，但是我对当前文件夹有读写权限，我可以看到这个没有权限的文件，因为我对这个文件所属的块没权限，但是这个权限是“放在”我的文件夹块中，我可以看到自己文件这一块的信息 把文件夹当做为文件，去理解权限 权限对文件的作用r：读写文件的内容w: 编辑新增修改，但是不能删除x: 可以执行 权限对目录的作用r: 可以查询目录下的文件名 (ls)w: 可以修改目录的结构，比如新建文件和目录，删除文件或目录，重命名文件或文件夹(touch rm mv cp)x: 可以进入目录(cd) 基本权限的修改chmod [option] 模式 文件名-R 递归 就是说文件夹下的所有文件都赋予 模式写法1例如 chmod u+x learning_temp_file给文件的所有者u(所属组g,其他人o)添加上执行权限x(读r,写w)例如 chmod u+x,g+x learning_temp_file多个赋予可以用,分隔例如 chmod u-x learning_temp_file可以+权限，相应地也就可以-权限 写法2例如 chmod u=rwx,g=rw learning_temp_file 写法3使用数字来代表权限r—4w—2x—1例如 rwxr-xr-x 就可以表示为 755chmod u=rwx,g=rx,o=rx learning_temp_file 相当于 chmod 755 learning_temp_file一般对目录的权限赋予 0 5 7 用户组权限修改在创建用户的时候如果不指定组就会创建一个和用户名相同的组 chown 用户名 文件名chown donscoco:donscoco_group file_name 也可以直接添加组 修改所有组chgrp 组名 文件名 小思考任务现在我需要为一个老师创建一个目录老师是目录的所有者，拥有所有权限老师的学生拥有查看这个目录的权限其他人没有这个目录的权限 处理groupadd teacher_group 创建一个老师的分组useradd -G teacher_group teacher 为分组添加用户useradd -G teacher_group student1mkdir teacher_course_dir为创建一个老师的文件夹chmod 750 teacher_course_dir 给文件赋予不同角色对应的权限chown teacher:teacher_group teacher_course_dir 将文件的所有权交给老师,假设老师的分组为teacher_group 文件默认权限umask查看默认权限0022第一位0：文件特殊权限022：文件默认权限可以 在umask后面添加值 例如 umask 026,但是这是临时的 目录默认权限目录默认权限为777默认权限777-umask的022 为 755 文件默认权限文件默认不能建立执行文件，必须手工赋予执行权限所以文件默认权限最大为666默认权限需要换算成字母在相减建立后的默认权限，为666-umask的022 修改unmask###临时修改1umask 026 ###永久修改1vi /etc/profile 文件特殊权限ACL权限文件都只有 一个所有者，一个用户组，还有其他三种角色,如果出现：这里ACL出现就是为了解决用户身份不够的情况的 查看分区的ACL权限是否开启dumpe2fs -h 目标分区 –目标分区如/dev/sda5 等；可通过df或者mount查看文件系统(对应分区)的挂载点-h 显示超级块的信息，而不显示磁盘块组的详细信息在返回的信息中如果有这个Default mount options: user_xattr acl就表示分区可以使用acl权限 开启分区ACL权限临时开启重新挂载根分区并挂载加入ACL权限mount -o remount,acl / 永久开启修改配置文件vi /etc/fstab在配置文件中加入UUID=1ae5f12f-79c1-47d4-bed7-941ab9385396 / ext4 defaults,acl 1 1然后重启系统或者重新挂载文件系统mount -o remount /ps: /etc/fstab 在改动时要非常小心，这个文件会直接影响linux系统的启动 ACL权限查看getfacl 文件名 ACL权限设定与删除setfacl [option] 文件名[option]-m：设定ACL权限-x：删除指定的ACL权限-b：删除所有的ACL权限-d：设定默认的ACL权限-k：删除默认的ACL权限-R：递归设定ACL权限 ACL权限设定给用户dons设定对dir_name的读写权限setfacl -m u:dons:rw dir_name给用户组dons_group设定对dir_name的读写权限setfacl -m g:dons_group:rw dir_name这个+代表就是ACL权限，具体什么样的权限就需要通过getfacl 文件名 来查看 ACL权限删除给用户dons删除对dir_name的权限setfacl -x u:dons dir_name给用户组dons_group设定对dir_name的读写权限setfacl -x g:dons_group dir_name删除文件的所有ACL权限setfacl -b dir_name ACL权限递归给 dir_name 下的 其他文件赋予acl权限setfacl -m u:dons:rx -R dir_name递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限 ACL默认权限在对一个文件夹执行赋予递归ACL权限之后，默认在这个文件夹新建的文件是没有ACL权限的ACL默认权限：默认权限的作用是如果给父目录设定了默认的ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限setfacl -m d:u:dons:rx -R dir_name 最大有效权限maskmask是用来指定最大有效权限的。如果我给用户赋予ACL权限，是需要和mask的权限做与运算才能得到用户真正的权限的 修改最大有效权限setfacl -m m:rx 文件名设定mask权限为r-x 使用 m:权限 格式 sudo权限什么是sudo权限？root 把本来只能超级用户执行的命令赋予普通用户执行sudo 操作对象是系统命令；之前将的权限都是用户操作文件的权限； visudo 命令打开/etc/sudoers文件 其中有一条root ALL=(ALL) ALL中root 表示给哪个用户赋予sudo权限ALL=(ALL) 被管理者的主机地址 = （可使用的身份）;表示 允许 root 在任何主机中使用任何身份ALL 授权命令（绝对路径）；比如说如果想给一个用户donscoco赋予重启权限可以在配置文件/etc/sudoers中加入donscoco ALL=(ALL) /sbin/shutdown -r now ps：可以通过 man 5 /etc/sudoers 来查看配置文件的帮助说明 sudo的安全问题给其他用户赋予能创建新用户的权限donscoco ALL=/usr/sbin/useradd没有括号（ALL）默认就是按root身份;可以切换到donscoco使用sudo -l查看 这里在赋予设置密码权限的时候，千万不能直接使用/usr/bin/passwd因为使用sudo系统是把用户donscoco当做root的身份来对待的，用户donscoco可以使用 sudo /usr/bin/passwd root 直接更改root 的 密码使用密码赋予权限：donscoco ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd &quot;&quot;, !/usr/bin/passwd root!/usr/bin/passwd root 禁止 使用/usr/bin/passwd命令对root进行操作 给其他用户赋予vi命令/etc/shadow 这个文件是保存密码的文件任何用户对这个权限都是000,包括root但是root 可以查看和更改/etc/shadow的内容如果我们在给一个用户赋予 /bin/vi 的权限这个用户使用sudo /bin/vi /etc/shadow 去改变密码或者删除密码，那么也是一个很严重的问题 其他安全相关的权限这里以下的权限尽量少修改 SetUIDSetUID功能只有可执行的二进制程序才能设定SUID权限命令执行者要对该程序有x可执行权限命令执行者在执行该程序时获得该程序文件属主的身份SetUID只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效 /etc/shadow文件权限是000，那么普通用户在改自己密码的时候又是怎么对 /etc/shadow进行修改的呢？这里 /usr/bin/passwd的信息如下passwd 命令被设置了SUID权限只要执行/usr/bin/passwd命令，执行命令人的身份就会变成执行文件所有者的身份root，所以普通用户可以改自己的密码 设定SUIDchmod 4775 file_namechmod u+s file_name这里4 就是SUID的意思，也可以使用第二句 取消SUIDchmod 0775 file_namechmod u-s file_name 定期检查危险的SUID123456789101112131415161718#!/bin/bashfind / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check#搜索系统中所有拥有SUID和SGID的文件，并保存到临时文件中for i in $(cat /tmp/setuid.check)#做循环，每次循环取出临时文件中的文件名do grep $i /root/suid.log &gt; /dev/null #对比这个文件名是否在模板文件中 if["$?"!="0"] #检查上一个命令的返回值，如果不为0，证明上一个命令报错 then ehco "$i is not in listfile!" &gt;&gt; /root/suid_log_$(date+%F) #如果文件名不在模板中，则输出错误信息，报错到日志中 fidonerm -rf /tmp/setuid.check#删除临时文件 SetGID只有可执行的二进制程序才能设置SGID权限命令执行者要对该程序有x执行权限命令执行在执行程序的时候，组身份升级wei为该程序文件的属组SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效 Sicky BITchattr权限chattr [+-=] [选项] 文件或目录名-+：增加权限–：删除权限-=：等于某权限]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件安装管理]]></title>
    <url>%2F2018%2F11%2F24%2FLinux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[软件包管理软件包分类源码包linux 一开始的包就是 .tar.gz 的源码包，打开可以看到里面是纯C语言的源码包优点和缺点： 开源 可以自由选择功能 软件是编译安装，所以更加适合自己的系统，更加稳定，效率更高 卸载方便 安装过程步骤多，尤其装较大软件集合的时候 编译过程时间较长，比二进制长 rpm包也叫 二进制 包，系统默认包是将源码包经过编译后的二进制包windows中的软件包是经过编译的，是二进制包优点和缺点： 包管理系统简单，安装，升级，查询，卸载简单 安装速度比源码包快 经过编译，不能看到源码 功能依赖不如源码包灵活 依赖性，一个包依赖另一个包，需要取装另一个包，另一个包又依赖其他几个包等 源码包和rpm包选择？因为rpm包是别人已经编译好的，他不一定最适合我的机器，所以，对于大型服务，有很多访问的最好使用源码包 脚本安装包其实linux中就rpm包和源码包两种，脚本安装包就是把复杂的安装过程写成程序脚本，实际安装的还是源码包或二进制包 rpm命令管理rpm包的来源如果通过光盘来的，挂载/mnt/cdrom/Packages rpm包命名规则软件包名-软件版本-软件发布次数.适合的linux平台.适合的硬件平台.rpm例如httpd-2.2.15-15.el6.centos.1.i686.rpmjdk-7u80-linux-x64.rpm rpm包的依赖性包名和包全名的概念httpd-2.2.15-15.el6.centos.1.i686.rpm是包全名，其中的httpd是包名包全名：操作的包是没有安装的软件包时，使用包全名包名：操作已经安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库 rpm安装rpm -ivh package_full_name.rpm-i 安装-v 显示详细信息-h 显示进度 升级与卸载rpm -Uvh package_full_name.rpm-U 升级rpm -e package_name-e 卸载其实卸载也可以手动去删除相关的文件就行，只是通过rpm包装的文件会分布在各个地方，使用命令能方便删 rpm查询查询是否安装rpm -q 包名 查询已经安装的所有rpm包rpm -qa可用管道符通过grep去查 查询软件包的详细信息rpm -qi 包名 rpm包默认安装位置 位置 描述 /etc/ 配置文件安装目录 /usr/bin/ 可执行命令安装目录 /usr/lib/ 程序使用的函数库保存位置 /usr/share/doc/ 基本软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 查询包中文件安装位置rpm -ql 包名 查询系统文件属于哪个RPM包rpm -qf 系统文件名 查询软件包的依赖性rpm -qR 包名-R 查询软件包的依赖性-p 查询未安装包的信息 RPM包校验rpm -V 包名可以返回这个包中哪些文件被人修改过，即便是注释改变也一样会报例如S.5....T. c /etc/httpd/conf/httpd.conf验证信息对应表：| S | 文件大小是否改变 || —- | ————————- || M | 文件类型或者文件权限（rwx）是否改变 || 5 | 文件MD5校验和是否改变（相当于文件内容是否改变） || D | 设备主从代码是否改变 || L | 文件路径是否改变 || U | 文件所有者是否改变 || G | 文件所属组是否改变 || T | 文件修改时间是否改变 || . | 没有改变 |c 代表文件类型；对应表| c | 配置文件(config file) || —- | ————————- || d | 普通文件(documentation) || g | ghost file 鬼文件，表示不该被rpm包含 || r | 描述文件(read me) || L | 授权文件 (license file) | rpm包中文件提取rpm2cpio 包全名 | cpio -idv.文件绝对路径-rpm2cpio 将rpm包转换为cpio格式的命令-cpio 一个标准工具一般用于，不小心删除了某个命令；从别的包提取过来例如 现在不小心删除了 /bin/ls 命令rpm -qf /bin/ls先查询文件属于哪个包rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取RPM包中的ls命令到当前目录的/bin/ls 下cp /root/bin/ls /bin/ 把ls文件复制回去，修复文件丢失 yum在线管理官方提供服务器，将所有软件包都放到官方服务器上，当进行yum在线安装的时候，可以自动解决依赖性问题 yum源文件位置：/etc/yum.repos.d/文件：CentOS-Base.repo 12345678[base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-6 [base] 容器名称 name 容器说明，可以自己随便写 mirrorlist 镜像站点 baseurl yum源服务器地址，默认是CentOS官方yum源服务器 enabled 次容器是否生效，不写默认生效 ；1：生效；0：不生效 gpgcheck 1 指rpm数字证书生效，0 不生效 gpgkey 数字证书公钥文件保存位置 光盘搭建yum源yum源默认是用网络来作为yum源；如果不想通过网络，如何使用yum源？可以搭建本地yum源，使用光盘等mkdir /mnt/cdrom/ 建立挂载点mount /dev/cdrom /mnt/cdrom/ 挂载光盘cd /etc/yum.repos.d 进入yum源目录mv CentOS-Base.repo CentOS-Base.repo.bak 是在线yum源失效，模拟，或者改文件内容 enabled = 0vi CentOS-Media.repo 修改光盘的yum源，使其生效接下来将baseurl 项改为baseurl = file:///mnt/cdrom 改为光盘挂载点地址enabled = 1 把enabled 改为1 使其生效 yum命令查询yum list 查询所有可用软件包列表yum search 关键字 搜索服务器上所有关键字相关的包 安装yum -y install 包名-y自动回答yes 升级yum -y update 包名-y 自动回答yes 卸载yum -y remove 包名 yum软件组管理命令yum grouplist 列出所有可用的软件组列表yum groupinstall &quot;软件组名&quot; 安装指定软件组，软件组名可有yum grouplist查出yum groupremove &quot;软件组名&quot; 卸载指定软件组 源码包管理源码包和rpm包区别安装之前的区别：概念上的区别安装之后的区别：安装位置不同 源码包安装位置任意，但是一般我们把它放在/usr/local/中源码包没有卸载命令，需要找到文件位置，手动删除 源码包安装 安装C语言编译器—gcc 下载源码包—官方网站下载 解压缩下载的源码包tar 进入源码包cd 执行./configure类似的构建文件配置与检查，可以通过./configure --help 查看帮助，定义需要的功能选项，检测环境是否符合安装要求；把定义好的功能选项和检测系统环境信息都写入Makefile文件，便于后续的编辑 指定安装位置例如 ./configure --prefix=/usr/local/apache2 make编译 –直接在当前目录下make make install 源码包的INSTALL一般会有安装说明 源码包卸载直接删除安装的位置目录文件即可 安装注意事项源代码保存位置：/usr/local/src/软件安装位置：/usr/local/ make编译make clean 万一报错，可以使用这个命令清除make install 编译安装 如果编译安装出错，不仅要make clean，还要删除/usr/local/下的文件夹 脚本安装包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP protocol]]></title>
    <url>%2F2018%2F10%2F25%2FHTTP%2F</url>
    <content type="text"><![CDATA[名词解析 URI :(uniform resource identifier) 统一资源定位符；用来标识互联网上的唯一资源 URL :(uniform resource locator) 统一资源定位器；e.g:http://user:pass@host.com:80/path?query=string#hash 此类格式都叫URL，http，ftp协议等 URN :(Uniform Resource Name) 统一资源名称 TCP协议 HTTP请求返回的完整过程： 其中每个节点都代表HTTP为我们做的事情 网络模型网络模型有七层标准模型和经典五层模型，这里展示五层模型 物理层：定义物理设备如何传输数据 数据链路层：通信实体间建立数据链路连接 网络层：为数据在实体间传输创建逻辑链路 传输层：向用户提供可靠的端到端(end to end)的服务传输层主要有两个协议TCP和UDP；什么是端到端的服务呢？比如我们建立了客户端到服务器的连接之后，他们两端如何去传输数据，传输的方式都是在这里定义的；我们传输的数据有可能很小有可能很大，如果很大不能一次传输过去，那么就要分包分片；分后传输过去后又如何组装也是在这里定义的； 应用层：为软件提供服务例如HTTP；构建于TCP协议之上的；屏蔽了网络传输相关细节 HTTP报文格式 http报文都有一个首行（不属于请求头） method：GET POST DELET PUT … URL： 协议版本 返回码code: 不同code代表不同的意思 200,,301，302，404,500等 header 首行换行后就是header body header 换行后再空行 就是body 认识HTTP Client 什么是HTTP Client？只要实现了一个发送标准HTTP请求的工具，那就是HTTP Clientps: http只是负责返回数据，而真正展示页面的是浏览器，浏览器拿到数据后对数据进行渲染，得到结果展示给用户 使用 curl 工具，在命令行中 curl baidu.com会得到为什么和在浏览器看到的不一样？因为浏览器在得到数据解析识别 meta 后，根据 http-equiv 重定向到 www.baidu.com 浏览器同域限制 跨域如何请求资源？被请求资源的http头设置 ‘Access-Control-Allow-Origin’:’*’; 也可以设置具体的url地址，指定特定的服务能请求e.g：’Access-Control-Allow-Origin’:’http://donscoco.github.io&#39;---只有http://donscoco.github.io可以跨域请求这个资源ps:就算头没有设置，请求也是能请求到，只是浏览器识别不是同一域而且没有’Access-Control-Allow-Origin’所以会忽略 什么是跨域？跨域，指的是浏览器不能执行其他网站的脚本。 它是由浏览器的同源策略造成的，是浏览器施加的安全限制。浏览器运行标签上的路径加载内容，不会在乎是否加了’Access-Control-Allow-Origin’:’*’; CORS预请求 缓存 可缓存性Cache-Control:http请求所经过的路径中，包括经过的一些http代理服务器都可以对http的内容进行缓存的操作public 浏览器，代理服务器都进行缓存private 只有浏览器缓存no-cache 不缓存 到期max-age=设置缓存时间；过期之后浏览器才会再次发送请求到服务端s-maxage=代理服务器读取的缓存时间 重新验证must-revalidate 在max-age 过期后用于验证proxy-revalidate 用于缓存服务器的过期验证 其他no-storeno-transform 验证头Last-Modified 上次修改时间Etag数据签名:常用的数据签名是对内容进行一个哈希计算；配合if-Match或者if-Non-Match使用对比资源签名判断是否使用缓存; Cookie cookie通过Set-Cookie设置 e.g: ‘Set-Cookie’:’id=123’ cookie结构：cookie是键值对的形式，可以设置多个 cookie流程：cookie是服务器返回的时候设置到浏览器的，保存在浏览器里面的数据，浏览器下一次同域的请求中会带上cookie 多个cookie：使用数组 1['id=123','name=donscoco'] 来表示 cookie属性： 属性之间使用;分隔; max-age和expires设置过期时间；[‘id=123’,’name=donscoco;max-age=10’] max-age是多久过期，expires是到什么时候过期; Secure只有在https的时候发送; HttpOnly无法通过document.cookie访问（为了安全考虑，如CSRF攻击）[‘id=123’,’name=donscoco;HttpOnly’]; cookie共享：不同域名之间的cookie是不能共享的；如果想在一级域名下所有的二级域名都能读到cookie可以在访问一级域名test.com时设置[‘id=123’,’name=donscoco;domain=test.com’]那么a.test.com和b.test.com都可以拿到同样的cookie；ps：不能跨域名设置cookie；e.g：a.test.com 不能给 test.com 设置cookie Cookie和SessionCookie不等于session；只是两者也是不同的概念，只是一般我们使用cookie来保存session，例如对于每个网站来说每个用户的session都是不一样的，这样客户端请求服务的时候会带上cookie，如果cookie中有之前存放的session，那么服务器就可以识别用户；这里session就是用于定位用户，只要能定位到用户，那就是一种session的实现方案，并不一定非要通过cookie来实现； HTTP连接 http的请求是建立在TCP的连接上的http请求发送的时候要先去创建一个tcp连接，在tcp连接上面把请求发送并且接受返回；在经过一次请求与返回之后，TCP和服务器的连接如果保持，那下次请求的时候可以直接使用这个TCP连接，但是在没有请求的时候是一种消耗，如果断开，下次请求的时候就要重新去进行三次握手建立连接；tcp默认会同时创建6个连接；如果连接满了剩余的请求就会进入等待，这里是说同时存在6个连接，传输后不一定会继续使用原来的连接，看connection会不会复用，可能是其他连接，但是同时存在的连接不超过6个 TCP长连接什么是长连接？客户端和服务端建立TCP连接后保持连接长连接的设置：&#39;connection&#39;:&#39;keep-alive&#39;客户端和服务端都可以设置这个字段，这里如果服务端返回的如果是不想保持，浏览器也还是会关掉浏览器请求会尽量地去复用已有的TCP连接，等有剩余的连接空出来;观察下图 ConnectionID和Waterfall字段； TCP短连接什么是短连接？客户端和服务端建立TCP连接经过一次请求返回后就关闭连接短连接的设置：’connection’:’close’浏览器不会去复用TCP连接，每个请求都建立一个新的TCP连接;观察下图 ConnectionID和Waterfall字段； 信道复用在http2里面；在TCP连接上面，我们可以并发地去放HTTP请求，也就是说，我们在连接一个网站(同域)的时候，只需要一个连接 数据协商 概念：客户端向服务端发送请求时，向服务端表明，自己希望拿到的数据格式是怎么样的。 请求 Accept 告诉服务器我希望的数据类型，可以是多个，用,分隔 Accept-Encoding 告诉服务器我的数据是怎样的编码方式进行传输,流行的有（gzip,deflate,br） Accept-Language 表示我希望要的语言类型,这个一般 是浏览器自动加的，浏览器会根据系统语言来填写这个 User-Agent 客户端的类型，告诉服务器我是PC端还是移动端 返回 Content-Type 表示我实际返回的是什么样的数据格式 Content-Encoding 声明我服务端返回的数据是什么编码 Content-Language 表示返回的语言类型 重定向服务端示例 客户端访问http://localhost:8080后跳转到http://localhost:8080/new展示这里要状态吗和Location一起使用，状态码设置200依然不会跳转 301和302区别301指永久跳转，302是临时跳转浏览器下次再遇到请求那个会跳转301的路径时，会自动再加上跳转后的路径，不用再去经过服务器处理301重定向告诉浏览器下一次再出现这个路径的访问的时候，直接在浏览器这边把他变成一个新的路径就可以了，不用经过服务器再去指定一个新的location而且还会默认在浏览器留下缓存 HTTPS HTTP概念：超文本传输协议（HTTP）是用于传输诸如HTML的超媒体文档的应用层协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用;也就是说，一个不会静默丢失消息的协议，如UDP。HTTPS概念：HTTP Strict Transport Security (通常简称为HSTS) 是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源, 禁止HTTP方式.Strict Transport Security解决了这个问题；只要你通过HTTPS请求访问银行网站，并且银行网站配置好Strict Transport Security，你的浏览器知道自动使用HTTPS请求，这可以阻止黑客的中间人攻击的把戏。HTTP的包是明文传输HTTPS是在HTTP基础上进行加密 TTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。加密公钥私钥主要是在握手的时候进行传输 私钥 公钥更多参考 http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/ IN ACTION证书生成1openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privkey.pem -out localhost-cert.pem 得到 localhost-privkey.pem 和 localhost-cert.pem 文件 Nginx 配置:12345678910111213141516171819202122232425262728293031proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;server &#123; listen 80; # listen [::]:80 default_server; server_name test.com; # return 302 https://$server_name$request_uri; location / &#123; proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; &#125;&#125;server &#123; listen 443 http2; server_name test.com; http2_push_preload on; ssl on; ssl_certificate_key ../certs/localhost-privkey.pem; ssl_certificate ../certs/localhost-cert.pem; location / &#123; proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; &#125;&#125; HTTP2 数据的传输： http2 所有数据都是以二进制进行传输的，都是以帧进行传输 http1 里面传输是通过字符串来传输的 HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮 多路复用 即连接共享，即每一个request都是是用作连接共享机制的。 一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 多路复用原理图： 请求返回无序： http2 同一个连接发送多个请求不需要按照顺序来返回 这个也是数据用帧来传输带来的好处，也进一步带来了可以并发传输，大大增加了效率 头信息压缩 头信息压缩提高效率的功能； 在http1里面每次请求和返回的头都是要完整返回的，但是头里面很多字段都是字符串，会导致传输的额外开销 推送 传统的http请求只能客户端发起请求，然后服务器响应请求；客户端是主动方，服务端是被动方； 在HTTP2里面，服务端是可以主动发起数据传输的 举个栗子：html中都有一些css，js之类的文件，在请求了html文本之后，再根据css，js的地址去请求；顺序是先得到文本在浏览器解析后再去请求css和js，这是一个串行的过程；有推送功能后，在返回html时一起推送css和js，大大提高了效率 http2定义上没有和https相关，但是因为http2是google之前开发的一个叫spdy演化而来，所以，要使用http2要支持https HTTP和HTTPS区别 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。]]></content>
      <categories>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>HTTP2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thread pools]]></title>
    <url>%2F2018%2F10%2F18%2FthreadPool%2F</url>
    <content type="text"><![CDATA[A simple example 123456789private Executor executor = new ThreadPoolExecutor(4, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue(500));...executor.execute(new Runnable() &#123; @Override public void run() &#123; function(...); &#125;&#125;);.. Benefits of using thread pools Reduce resource consumption —Reduce the consumption of thread creation and destruction by reusing the created threads. Improve response speed Improving thread manageability —Monitoring and tuning Use of thread pool Creation of thread pool we can create a thread pool such like: 1new ThreadPoolExecutor(corePoolSize, maximumPoolSize,keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler); parameter: corePoolSize : When a task is submitted to the thread pool, the thread pool creates a thread to execute the task, even if other idle base threads are able to execute the new tasks. The thread is not created until the number of tasks to be executed is greater than the thread pool’s basic size. maximumPoolSize : The maximum number of threads allowed by thread pool.If the queue is full and the number of threads created is less than the maximum number of threads, the thread pool creates new threads to perform tasks. keepAliveTime : The thread pool’s working threads are free after the idle thread. So if there are many tasks, and each task is executed in a relatively short time, you can adjust this time to improve the utilization of threads. milliseconds : runnableTaskQueue ： Block queue for saving tasks waiting to be excused. It can be as follows: ArrayBlockingQueue LinkedBlockingQueue SynchronousQueue — A blocking queue that does not store elements. Each insertion operation must wait until another thread calls the removal operation. PriorityBlockingQueue — An infinite blocking queue with priority RejectedExecutionHandler : When the queue and thread pool are full, indicating that the thread pool is saturated, a strategy must be adopted to handle the new tasks submitted. It can be as follows: AbortPolicy : throw Exception CallerRunsPolicy : use only the thread of the caller to run the task. DiscardOldestPolicy : discard the last task in the queue and perform the current task. DiscardPolicy : discard Submission of the task We can use execute to submit a task, but the execute method does not return a value, so it is impossible to determine whether the task was successfully executed by the thread pool. The following code shows that the task entered by the execute method is an instance of a Runnable class. 123456threadsPool.execute(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125;&#125;); We can also submit a task using the submit method, which returns a future. We can use the future to determine whether the task is successful, get the return value through the future’s get method, block the get method until the task is complete, and block one using the get (long timeout, TimeUnit unit) method. Return immediately after a period of time, and it is possible that the task is not executed. 12345678910Future&lt;Object&gt; future = executor.submit(harReturnValuetask);try &#123; Object s = future.get();&#125; catch (InterruptedException e) &#123; // handler interruptedException&#125; catch (ExecutionException e) &#123; // handler executionexception&#125; finally &#123; executor.shutdown();&#125; Closure of thread pool We can close the thread pool by calling the shutdown or shutdownNow methods of the thread pool, which traverse the worker threads in the thread pool and then interrupt the thread one by one, so tasks that cannot respond to interruptions may never be terminated. But there are some differences. shutdownNow first sets the state of the thread pool to STOP, then tries to stop all threads executing or suspending tasks, and returns a list of tasks waiting to be executed, whereas shutdownNow just sets the state of the thread pool to SHUTDOWN, and then interrupts all threads that are not executing. Service threads. As long as one of the two closing methods is invoked, the isShutdown method returns true. Calling the isTerminated method returns true when all tasks are closed. As for which method we should invoke to close the thread pool, it should be determined by the task characteristics submitted to the thread pool, usually calling shutdown to close the thread pool, or calling shutdownNow if the task is not necessarily complete. Analysis of thread pool The main workflow of the thread pool is as follows:we can see from the above picture. When a new task is submitted to the thread pool, the processing flow of the thread pool is as follows: First, thread pool determines whether the basic thread pool is full. If it is not full, create a worker thread to perform the task. Full, then enter the next process. Secondly, the thread pool determines whether the work queue is full. If not, the new task will be stored in the work queue. Full, then enter the next process. Finally, the thread pool determines whether the entire thread pool is full. If it is not full, a new worker thread is created to perform the task, and when it is full, the saturation policy is given to handle the task. Source code 1234567891011public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125;else if (!addIfUnderMaximumPoolSize(command)) reject(command); &#125;&#125; Working thread When a thread pool creates a thread, it encapsulates the thread as a worker thread, which, after executing the task, loops indefinitely to fetch the task in the work queue for execution. We can see this from the run method of Worker: 123456789101112public void run() &#123; try &#123; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125;&#125; Rational configuration of thread pool To configure thread pools reasonably, we must first analyze the characteristics of tasks, which can be analyzed from the following aspects: Nature of task : CPU intensive tasks, IO intensive tasks and hybrid tasks. Tasks with different tasks can be processed separately from different sizes of thread pools. CPU intensive tasks are configured as small as possible, such as thread pools that configure Ncpu+1 threads. IO-intensive tasks configure as many threads as possible, such as 2 * Ncpu, because threads are not always executing tasks. Hybrid tasks, if they can be split, are split into a CPU-intensive task and an IO-intensive task. As long as the time difference between the two tasks is not too large, the throughput after decomposition is higher than that of serial execution. If the time difference between the two tasks is too large, it is not necessary. Decompose. We can get the CPU number of the current device through the Runtime.getRuntime ().AvailableProcessors () method. Priority of tasks : Tasks with different priorities can be handled using priority queue PriorityBlockingQueue. It allows high-priority tasks to be executed first, and it is important to note that low-priority tasks may never be executed if high-priority tasks are always submitted to the queue. Task execution time : Tasks with different execution times can be handled by thread pools of different sizes, or priority queues can be used to allow tasks with short execution times to execute first. Task dependency : Is it dependent on other system resources, such as database connection? Depending on the database connection pool task, because threads need to wait for the database to return the results after submitting SQL, if the longer the wait, the longer the CPU idle time, then the number of threads should be set, so as to better use the CPU. It is suggested that bounded queues be used. Bounded queues can increase the stability and early warning capability of the system, and can be set up as large as needed, such as several thousand.It is suggested that bounded queues be used. Bounded queues can increase the stability and early warning capability of the system, and can be set up as large as needed, such as several thousand. If unbounded queues are used, if the system goes wrong, memory may be crammed, affecting other systems. Thread pool monitoring Monitor the parameters provided by thread pool. There are properties in the thread pool that can be used when monitoring thread pools. taskCount The number of tasks that thread pools need to perform. completedTaskCount The number of tasks that the thread pool has completed in the process of running. Less than or equal to taskCount. largestPoolSize The maximum number of threads that thread pool has ever created. This data can be used to see if the line pool is full. getPoolSize The number of threads in the thread pool.-getActiveCount Gets the number of threads of activity. Monitor by extending thread pool. By inheriting the thread pool and overwriting the beforeExecute, afterExecute, and terminated methods of the thread pool, we can do something before, after, and before the thread pool is closed. For example, the average execution time, maximum execution time and minimum execution time of monitoring tasks. These methods are empty methods in the online pool. Such as:1protected void beforeExecute(Thread t, Runnable r) &#123; &#125; More Transmission gate : ifeveTransmission gate : a tiny huskyTransmission gate : jonnyTransmission gate : OracleTransmission gate : csdnTransmission gate : csdn]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Util</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F01%2F30%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言这里只是在学习linux相关知识过程中，对常用命令做的一个总结笔记更多命令可访问 http://man.linuxde.net/ 命令格式命令 [选项] [参数]个别命令可以不遵循这种格式 ls [选项] [目标文件或目录]查询目录中的内容 ls -als -l 显示文件详细信息ls -i 显示文件的inode系统每个文件或文件夹都有他自己的inode号，查找根据inode号查 cd 切换目录pwd 显示当前路径 Ctrl cctrl ltab 补全 环境相关语言LANG=en_USLANG=zh_CH.utf8 时间#文件与目录处理命令 建立目录mkdir -p [目录名] 建立目录-p 递归创建 切换目录cd [目录]cd ~cd ..cd .cd - 相对路径cd ./dons 进入当前目录下的dons目录cd ../home/dons进入上一级目录下的home的dons 绝对路径cd /home/dons 查询目录所在位置pwd –print working directory 删除空目录rmdir [目录名]remove empty directory 删除文件或目录rm -rf [文件或目录]-r 删除目录-f 强制删除小心删除 rm -rf /删除掉以/开头的，rm -rf 可以让系统“自杀” 复制命令cp [选项] [原文件或目录] [目标目录]如果目标目录不加文件名，则原名复制；eg：cp test /tmp/反之，则是等名复制；eg：cp -a test /tmp/new_test-r 复制目录,不加-r 默认复制文件-p 带文件属性复制，不加复制的时间是复制的时候的文件-d 若源文件是链接文件，则复制链接属性-a 相当于上面 -pdr 剪切或改名命令mv [源文件或目录] [目标目录] linux 链接命令ln -s [原文件] [目标文件]link-s 创建软连接 硬链接拥有相同的i 节点和存储block快，可以看做是同一个文件可通过i节点识别不能跨分区不能针对目录使用就算x没了，硬链接也还是能指到id，相当于一个文件，可以使用ls -i可以发现两个id都是一样的图中 的 2 表示 这个文件有多少个链接数 软链接类似windows的快捷方式软链接拥有自己的block块，但数据块中只保存原文件的文件名和i节点号，没有实际数据例如 lrwxrwxrwx 中的l 就是指链接文件修改任意文件，另一个都改变删除原文件，软链接不能使用 搜索命令文件搜索命令locate [文件名]在后台数据库中按文件名搜索，搜索比find快；后台数据库—/var/lib/mlocate 有的版本可能叫其他的例如 slocate locatedb新建的文件没有记录进入后台数据库，因为后台数据库不是实时更新，也可以立刻更新 updatadb缺点：只能搜索文件名 更多：文件搜索规则 /etc/updatedb.conf 配置文件 find [搜索范围] [搜索条件]（慢）遍历整个根-name find /home -name ‘dons’-iname 不区分大小写-user 按所有者搜索-nouser 搜索没有所有者的文件，一般用来清理垃圾文件-mtime +10 搜索十天前修改的文件-atime +10 搜索十天前访问的文件-ctime +10 搜索十天前修改属性的文件这里+10 10 -10 分别是 今天1月20号 1/10号之前的，1/10当天，1/10号-1/20 -size [-25k|25k|+25k] 查找文件大小是小于25k的 等于25k的 大于25k的-size +20k -a -50k 查找文件大小是大于20k并且小于50k的文件 -a:and -o:or-inum 558528 查找 inode 节点号为 558528 的文件 linux 中的通配符*匹配任意内容?匹配任意字符[]匹配任意中括号内的字符更多详见https://abcfy2.gitbooks.io/linux_basic/content/first_sense_for_linux/command_learning/wildcard.html 命令搜索命令whereis-b:只查找可执行命令-m:只查找帮助文档which和whereis 一样，多加了别名 更多 whoami whatis whereis 字符串搜索命令grep [选项] 字符串 文件名在文件中匹配符合条件的字符串-i 忽略大小写-v 排除指定字符串如果想要使用模糊去匹配需要使用正则表达式，find中使用通配符 更多：管道 cat test.log | grep “2018-1-30” 帮助命令man [命令]manul 压缩与解压缩常用压缩格式 .zip .gz .bz2 .tar.gz .tar.bz2zip 压缩文件名 原文件 – 压缩文件zip -r 压缩文件名 原目录 – 压缩目录unzip 解压缩文件 gzip 原文件 – 压缩为.gz 格式；原文件会消失gzip -c 原文件 &gt; 压缩文件 – 压缩为.gz 个格式；原文件保留gzip -r 原文件gzip -d 压缩文件 – 解压缩文件gunzip 压缩文件 – 解压缩文件 bzip2 原文件 –压缩为.bz2格式，不保留原文件bzip2 -k 原文件 –压缩后保留原文件bzip2 -d 压缩文件 – 解压缩文件bunzip2 压缩文件 – 解压缩 -k 保留压缩文件 .tar.gz .tar.bz2 这类文件是因为gz，bz2打包不能连着文件夹一起打包，所以先打包成了.tar 再将这个文件打包成.gz打包命令 tartar -cvf 打包文件名 源文件 – 打包成.tar-c 打包-v 显示过程-f 指定打包后的文件-x 解打包tar -xvf 打包文件-zcvf 直接压缩为 .tar.gz-zxvf 直接解压缩 .tar.gz-jcvf 直接压缩为 .tar.bz2-jxvf 直接解压缩 .tar.bz2 linxu常见目录作用 / 根目录/bin 命令保存目录（普通用户权限）/sbin 命令保存目录（root权限）/boot 启动目录，包含启动相关文件，和开机有关/dev 设备文件保存目录/etc 配置文件保存目录/home 普通用户家目录/lib 系统库保存目录/mnt 系统挂载目录/media 挂载目录（常用于光盘挂载）/root 超级用户家目录/tmp 临时目录/proc 直接写入内存的/sys 直接写入内存的/usr 系统软件资源目录/var 系统相关文档内容 linux 关机与重启关机与重启shutdowm [选项] 时间-c: 取消前一个关机命令-h: 关机-r: 重启 时间的格式：05:30 凌晨5点30分 时间可以 now执行之后无法执行其他命令，但是可以将任务放到后台：1shutdown -r 05:30 &amp; 更多重启：reboot,init 6更多关机：不推荐使用，不会保存当前状态等信息 halt poweroff init 0为什么 init 0 init 6 ？这有关于linux系统运行级别https://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-101-3/index.html 退出登录logout 挂载命令什么是挂载？在linux中所有的存储设备，都必须挂载后才能正常使用，windows中用字母作为系统盘符，linux中用目录作为盘符；所以挂载其实就是分配盘符，只是分配的盘符叫挂载点，分配的过程叫挂载硬盘的分区是第一次设置好挂载后，以后每次启动机器自动挂载的而光盘，U盘等存储设备必须人为地来挂载 查询与自动挂载mount 查询系统中已挂载的设备mount -a 依据配置文件/etc/fstab 的内容，自动挂载 12345/dev/vda1 on / type ext3 (rw,noatime,acl,user_xattr)proc on /proc type proc (rw)sysfs on /sys type sysfs (rw)devpts on /dev/pts type devpts (rw,mode=0620,gid=5)none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw) /dev/vda1 on / type ext3 (rw,noatime,acl,user_xattr)中dev是硬件设备目录vd 是接口 还有 sd等a 代表硬盘5 是分区on 是挂载到/ 挂载到根分区ext3 是文件系统(rw,noatime,acl,user_xattr)是权限 proc on /proc type proc (rw)和sysfs on /sys type sysfs (rw)中proc和sysfs是内存的挂载点，内核自己挂载的，不要乱动！！！ 自动挂载配置/etc/fstab 文件是系统自动挂载配置 挂载命令格式mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点-t 文件系统： 加入文件系统类型来制指定挂载类型，可以是ext3，ext4，iso9660等文件系统-o 特殊选项： 可以指定挂载的额外选项eg：mount -o remount,noexec /home/ 这里的noexec会使得挂载为不能执行，坑人专用 执行完记得改回来！！！mount -o remount,exec /home/这里没有写 设备文件名 /dev/vda5 是因为 自动挂载配置文件里面已经能自动找到对应的 名字了对于没有在/etc/fstab 文件中的，例如 U盘，光盘等就要写上设备文件路径 挂载光盘 建立挂载点 mkdir /mnt/cdrom/ 挂载光盘 mount -t iso9660 /dev/cdrom /mnt/cdrom 或 mount /dev/sr0 /mnt/cdrom 省略文件系统选项，因为系统默认知道光盘的文件系统是 iso9660因为挂载默认会去执行读写权限，而光盘是不能写的，所以挂载光盘时候会出现mount: block device /dev/sr0 is write-protected, mounting read-only 这是正常的。 卸载命令umount 设备名或者挂载点umount /dev/sr0umount /mnt/cdrom 挂载U盘fdisk -l 查看U盘设备文件名;一般是 /dev/sdb1mount -t vfat /dev/sdb1 /mnt/usb/linux 默认是不支持NTFS文件系统的;想使用需要去往内核装NTFS驱动；或者安装fts-3G linux用户登陆查看命令w12319:10:04 up 8:17, 1 user, load average: 0.00, 0.00, 0.00USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 58.248.229.155 19:10 0.00s 0.00s 0.00s w 19:10:04 up 8:17, 1 user, load average: 0.00, 0.00, 0.00中19:10:04 当前系统时间up 8:17 系统到现在运行了多少个小时1 user 总登陆了1个用户load average: 0.00, 0.00, 0.00 系统在 1分钟 5分钟 15分钟的 平均负载pts/0 登陆方式是远程58.248.229.155 从哪个ip过来的USER：登陆的用户名TTY：登陆终端FROM：从哪个IP地址登陆LOGIN：登陆时间IDLE：用户闲置时间JCPU：指的是和该终端连接的所有进程占用的时间。这个时间里并不包括过去的后台作业时间，但包含当前正在运行的后台作业占用的时间PCPU：当前进程所占用的时间WHAT：当前正在运行的命令 last可以查看系统中所有的用户登陆信息和系统重启信息这个可以发现有黑客进入了你的计算机last命令默认读取的是 /var/log/wtmp 文件数据lastlog 记录的是系统所有用户的最后一次登陆lastlog 命令默认读取的是 /var/log/lastlog 文件 用户管理切换用户su [用户名]之后输入相应密码即可 添加用户useradduseradd 用户名passwd 目标用户名 –给指定用户名设置密码 useradd -G donscoco_group donscoco2 –添加用户的时候指定用户分组，没有指定分组系统会默认添加一个和用户名一样的分组 修改用户账户usermod –l donscoco dons –将用户的用户名dons改为donscocousermod –g dons_group donscoco –将用户 donscoco 加入到 dons_group组中 删除用户账户userdel donscoco –删除用户 donscocouserdel –r donscoco –删除用户，同时删除他的工作目录 查看用户id donscoco –查找donscoco的信息 添加用户组groupadd –g 666 donsgroup 添加一个groupID为666的用户组donsgroup 修改用户组groupmod –n dons_group donsgroup 修改用户组donsgroup为dons_group 删除用户组groupdel dons_group 为用户组添减成员gpasswd -a donscoco dons_group 为dons_group 组添加 donscocogpasswd -d donscoco dons_group 为dons_group 组移去 donscoco]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
